package {{packageName}}.security.jwt.infrastructure.config;

import {{packageName}}.security.jwt.domain.AuthoritiesConstants;
import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.SecurityWebFiltersOrder;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpMethod;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.web.server.header.ReferrerPolicyServerHttpHeadersWriter;
import org.springframework.security.web.server.header.XFrameOptionsServerHttpHeadersWriter;
import org.springframework.security.web.server.savedrequest.NoOpServerRequestCache;
import org.springframework.security.web.server.util.matcher.NegatedServerWebExchangeMatcher;
import org.springframework.security.web.server.util.matcher.OrServerWebExchangeMatcher;
import org.zalando.problem.spring.webflux.advice.security.SecurityProblemSupport;

import static org.springframework.security.web.server.util.matcher.ServerWebExchangeMatchers.pathMatchers;

@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
@Import(SecurityProblemSupport.class)
public class SecurityConfiguration {

  private final ApplicationSecurityProperties applicationSecurityProperties;
  private final TokenProvider tokenProvider;
  private final SecurityProblemSupport problemSupport;

  public SecurityConfiguration(
    TokenProvider tokenProvider,
    ApplicationSecurityProperties applicationSecurityProperties,
    SecurityProblemSupport problemSupport
  ) {
    this.tokenProvider = tokenProvider;
    this.problemSupport = problemSupport;
    this.applicationSecurityProperties = applicationSecurityProperties;
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    // @formatter:off
    http
      .securityMatcher(new NegatedServerWebExchangeMatcher(new OrServerWebExchangeMatcher(
        pathMatchers("/app/**", "/i18n/**", "/content/**", "/swagger-ui/**", "/v3/api-docs/**", "/test/**"),
        pathMatchers(HttpMethod.OPTIONS, "/**")
      )))
      .csrf()
        .disable()
      .addFilterAt(new JwtTokenFilter(tokenProvider), SecurityWebFiltersOrder.HTTP_BASIC)
      .exceptionHandling()
        .accessDeniedHandler(problemSupport)
        .authenticationEntryPoint(problemSupport)
      .and()
        .headers()
        .contentSecurityPolicy(applicationSecurityProperties.getContentSecurityPolicy())
        .and()
          .referrerPolicy(ReferrerPolicyServerHttpHeadersWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN)
        .and()
          .permissionsPolicy().policy("camera=(), fullscreen=(self), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), sync-xhr=()")
        .and()
          .frameOptions().mode(XFrameOptionsServerHttpHeadersWriter.Mode.DENY)
      .and()
      .requestCache()
      .requestCache(NoOpServerRequestCache.getInstance())
      .and()
      .authorizeExchange()
      .pathMatchers("/api/authenticate").permitAll()
      .pathMatchers("/api/auth-info").permitAll()
      .pathMatchers("/api/admin/**").hasAuthority(AuthoritiesConstants.ADMIN)
      .pathMatchers("/api/**").authenticated()
      .pathMatchers("/management/health").permitAll()
      .pathMatchers("/management/health/**").permitAll()
      .pathMatchers("/management/info").permitAll()
      .pathMatchers("/management/prometheus").permitAll()
      .pathMatchers("/management/**").hasAuthority(AuthoritiesConstants.ADMIN);
      return http.build();
    // @formatter:on
  }

}
